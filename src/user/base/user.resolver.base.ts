/*
//------------------------------------------------------------------------------ 
// This code was generated by Amplication. 
// 
// Changes to this file will be lost if the code is regenerated. 
//
// There are other ways to to customize your code, see this doc to learn more
// https://docs.amplication.com/docs/how-to/custom-code
//
//------------------------------------------------------------------------------
  */
import * as common from "@nestjs/common";
import * as graphql from "@nestjs/graphql";
import * as apollo from "apollo-server-express";
import * as nestAccessControl from "nest-access-control";
import { GqlDefaultAuthGuard } from "../../auth/gqlDefaultAuth.guard";
import * as gqlACGuard from "../../auth/gqlAC.guard";
import * as gqlUserRoles from "../../auth/gqlUserRoles.decorator";
import * as abacUtil from "../../auth/abac.util";
import { isRecordNotFoundError } from "../../prisma.util";
import { MetaQueryPayload } from "../../util/MetaQueryPayload";
import { PaginatedInterface } from "../../util/PaginatedInterface";
import { CreateUserArgs } from "./CreateUserArgs";
import { UpdateUserArgs } from "./UpdateUserArgs";
import { DeleteUserArgs } from "./DeleteUserArgs";
import { UserFindManyArgs } from "./UserFindManyArgs";
import { UserFindUniqueArgs } from "./UserFindUniqueArgs";
import { User } from "./User";
import { CommentFindManyArgs } from "../../comment/base/CommentFindManyArgs";
import { Comment } from "../../comment/base/Comment";
import { FeedbackFindManyArgs } from "../../feedback/base/FeedbackFindManyArgs";
import { Feedback } from "../../feedback/base/Feedback";
import { PublicationFindManyArgs } from "../../publication/base/PublicationFindManyArgs";
import { Publication } from "../../publication/base/Publication";
import { SocialinterractionFindManyArgs } from "../../socialinterraction/base/SocialinterractionFindManyArgs";
import { Socialinterraction } from "../../socialinterraction/base/Socialinterraction";
import { UsersOnCommunityFindManyArgs } from "../../usersOnCommunity/base/UsersOnCommunityFindManyArgs";
import { UsersOnCommunity } from "../../usersOnCommunity/base/UsersOnCommunity";
import { UsersOnEntrepriseFindManyArgs } from "../../usersOnEntreprise/base/UsersOnEntrepriseFindManyArgs";
import { UsersOnEntreprise } from "../../usersOnEntreprise/base/UsersOnEntreprise";
import { UsersSkillFindManyArgs } from "../../usersSkill/base/UsersSkillFindManyArgs";
import { UsersSkill } from "../../usersSkill/base/UsersSkill";
import { Candidate } from "../../candidate/base/Candidate";
import { Recruiter } from "../../recruiter/base/Recruiter";
import { UserService } from "../user.service";

@graphql.Resolver(() => User)
@common.UseGuards(GqlDefaultAuthGuard, gqlACGuard.GqlACGuard)
export class UserResolverBase {
  constructor(
    protected readonly service: UserService,
    protected readonly rolesBuilder: nestAccessControl.RolesBuilder
  ) {}

  @graphql.Query(() => MetaQueryPayload)
  @nestAccessControl.UseRoles({
    resource: "User",
    action: "read",
    possession: "any",
  })
  async _usersMeta(
    @graphql.Args() args: UserFindManyArgs
  ): Promise<MetaQueryPayload> {
    const results = await this.service.count({
      ...args,
      skip: undefined,
      take: undefined,
    });
    return {
      count: results,
    };
  }

  // @graphql.Query(() => [User])
  // @nestAccessControl.UseRoles({
  //   resource: "User",
  //   action: "read",
  //   possession: "any",
  // })
  // async users(
  //   @graphql.Args() args: UserFindManyArgs,
  //   @gqlUserRoles.UserRoles() userRoles: string[]
  // ): Promise<PaginatedInterface<User>> {
  //   const permission = this.rolesBuilder.permission({
  //     role: userRoles,
  //     action: "read",
  //     possession: "any",
  //     resource: "User",
  //   });
  //   const results = await this.service.findMany(args);
  //   const result = results.paginatedResult.map((result: User) =>
  //     permission.filter(result)
  //   );
  //   return { paginatedResult: result, totalCount: results.totalCount };
  // }

  @graphql.Query(() => User, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: "User",
    action: "read",
    possession: "own",
  })
  async user(
    @graphql.Args() args: UserFindUniqueArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<User | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: "read",
      possession: "own",
      resource: "User",
    });
    const result = await this.service.findOne(args);
    if (result === null) {
      return null;
    }
    return permission.filter(result);
  }

  // @graphql.Mutation(() => User)
  // @nestAccessControl.UseRoles({
  //   resource: "User",
  //   action: "create",
  //   possession: "any",
  // })
  // async createUser(
  //   @graphql.Args() args: CreateUserArgs,
  //   @gqlUserRoles.UserRoles() userRoles: string[]
  // ): Promise<User> {
  //   const permission = this.rolesBuilder.permission({
  //     role: userRoles,
  //     action: "create",
  //     possession: "any",
  //     resource: "User",
  //   });
  //   const invalidAttributes = abacUtil.getInvalidAttributes(
  //     permission,
  //     args.data
  //   );
  //   if (invalidAttributes.length) {
  //     const properties = invalidAttributes
  //       .map((attribute: string) => JSON.stringify(attribute))
  //       .join(", ");
  //     const roles = userRoles
  //       .map((role: string) => JSON.stringify(role))
  //       .join(",");
  //     throw new apollo.ApolloError(
  //       `providing the properties: ${properties} on ${"User"} creation is forbidden for roles: ${roles}`
  //     );
  //   }
  //   // @ts-ignore
  //   return await this.service.create({
  //     ...args,
  //     data: {
  //       ...args.data,

  //       candidate: args.data.candidate
  //         ? {
  //             connect: args.data.candidate,
  //           }
  //         : undefined,

  //       recruiter: args.data.recruiter
  //         ? {
  //             connect: args.data.recruiter,
  //           }
  //         : undefined,
  //     },
  //   });
  // }

  // @graphql.Mutation(() => User)
  // @nestAccessControl.UseRoles({
  //   resource: "User",
  //   action: "update",
  //   possession: "any",
  // })
  // async updateUser(
  //   @graphql.Args() args: UpdateUserArgs,
  //   @gqlUserRoles.UserRoles() userRoles: string[]
  // ): Promise<User | null> {
  //   const permission = this.rolesBuilder.permission({
  //     role: userRoles,
  //     action: "update",
  //     possession: "any",
  //     resource: "User",
  //   });
  //   const invalidAttributes = abacUtil.getInvalidAttributes(
  //     permission,
  //     args.data
  //   );
  //   if (invalidAttributes.length) {
  //     const properties = invalidAttributes
  //       .map((attribute: string) => JSON.stringify(attribute))
  //       .join(", ");
  //     const roles = userRoles
  //       .map((role: string) => JSON.stringify(role))
  //       .join(",");
  //     throw new apollo.ApolloError(
  //       `providing the properties: ${properties} on ${"User"} update is forbidden for roles: ${roles}`
  //     );
  //   }
  //   try {
  //     // @ts-ignore
  //     return await this.service.update({
  //       ...args,
  //       data: {
  //         ...args.data,

  //         candidate: args.data.candidate
  //           ? {
  //               connect: args.data.candidate,
  //             }
  //           : undefined,

  //         recruiter: args.data.recruiter
  //           ? {
  //               connect: args.data.recruiter,
  //             }
  //           : undefined,
  //       },
  //     });
  //   } catch (error) {
  //     if (isRecordNotFoundError(error)) {
  //       throw new apollo.ApolloError(
  //         `No resource was found for ${JSON.stringify(args.where)}`
  //       );
  //     }
  //     throw error;
  //   }
  // }

  // @graphql.Mutation(() => User)
  // @nestAccessControl.UseRoles({
  //   resource: "User",
  //   action: "delete",
  //   possession: "any",
  // })
  // async deleteUser(@graphql.Args() args: DeleteUserArgs): Promise<User | null> {
  //   try {
  //     // @ts-ignore
  //     return await this.service.delete(args);
  //   } catch (error) {
  //     if (isRecordNotFoundError(error)) {
  //       throw new apollo.ApolloError(
  //         `No resource was found for ${JSON.stringify(args.where)}`
  //       );
  //     }
  //     throw error;
  //   }
  // }

  @graphql.ResolveField(() => [Comment])
  @nestAccessControl.UseRoles({
    resource: "User",
    action: "read",
    possession: "any",
  })
  async comments(
    @graphql.Parent() parent: User,
    @graphql.Args() args: CommentFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Comment[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: "read",
      possession: "any",
      resource: "Comment",
    });
    const results = await this.service.findComments(parent.id, args);

    if (!results) {
      return [];
    }

    return results.map((result) => permission.filter(result));
  }

  @graphql.ResolveField(() => [Feedback])
  @nestAccessControl.UseRoles({
    resource: "User",
    action: "read",
    possession: "any",
  })
  async feedbacks(
    @graphql.Parent() parent: User,
    @graphql.Args() args: FeedbackFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Feedback[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: "read",
      possession: "any",
      resource: "Feedback",
    });
    const results = await this.service.findFeedbacks(parent.id, args);

    if (!results) {
      return [];
    }

    return results.map((result) => permission.filter(result));
  }

  @graphql.ResolveField(() => [Publication])
  @nestAccessControl.UseRoles({
    resource: "User",
    action: "read",
    possession: "any",
  })
  // async publications(
  //   @graphql.Parent() parent: User,
  //   @graphql.Args() args: PublicationFindManyArgs,
  //   @gqlUserRoles.UserRoles() userRoles: string[]
  // ): Promise<Publication[]> {
  //   const permission = this.rolesBuilder.permission({
  //     role: userRoles,
  //     action: "read",
  //     possession: "any",
  //     resource: "Publication",
  //   });
  //   const results = await this.service.findPublications(parent.id, args);

  //   if (!results) {
  //     return [];
  //   }

  //   return results.map((result) => permission.filter(result));
  // }

  @graphql.ResolveField(() => [Socialinterraction])
  @nestAccessControl.UseRoles({
    resource: "User",
    action: "read",
    possession: "any",
  })
  async socialinterractions(
    @graphql.Parent() parent: User,
    @graphql.Args() args: SocialinterractionFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Socialinterraction[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: "read",
      possession: "any",
      resource: "Socialinterraction",
    });
    const results = await this.service.findSocialinterractions(parent.id, args);

    if (!results) {
      return [];
    }

    return results.map((result) => permission.filter(result));
  }

  @graphql.ResolveField(() => [UsersOnCommunity])
  @nestAccessControl.UseRoles({
    resource: "User",
    action: "read",
    possession: "any",
  })
  async usersOnCommunities(
    @graphql.Parent() parent: User,
    @graphql.Args() args: UsersOnCommunityFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<UsersOnCommunity[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: "read",
      possession: "any",
      resource: "UsersOnCommunity",
    });
    const results = await this.service.findUsersOnCommunities(parent.id, args);

    if (!results) {
      return [];
    }

    return results.map((result) => permission.filter(result));
  }

  @graphql.ResolveField(() => [UsersOnEntreprise])
  @nestAccessControl.UseRoles({
    resource: "User",
    action: "read",
    possession: "any",
  })
  async usersOnEntreprises(
    @graphql.Parent() parent: User,
    @graphql.Args() args: UsersOnEntrepriseFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<UsersOnEntreprise[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: "read",
      possession: "any",
      resource: "UsersOnEntreprise",
    });
    const results = await this.service.findUsersOnEntreprises(parent.id, args);

    if (!results) {
      return [];
    }

    return results.map((result) => permission.filter(result));
  }

  @graphql.ResolveField(() => [UsersSkill])
  @nestAccessControl.UseRoles({
    resource: "User",
    action: "read",
    possession: "any",
  })
  async usersSkills(
    @graphql.Parent() parent: User,
    @graphql.Args() args: UsersSkillFindManyArgs,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<UsersSkill[]> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: "read",
      possession: "any",
      resource: "UsersSkill",
    });
    const results = await this.service.findUsersSkills(parent.id, args);

    if (!results) {
      return [];
    }

    return results.map((result) => permission.filter(result));
  }

  @graphql.ResolveField(() => Candidate, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: "User",
    action: "read",
    possession: "any",
  })
  async candidate(
    @graphql.Parent() parent: User,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Candidate | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: "read",
      possession: "any",
      resource: "Candidate",
    });
    const result = await this.service.getCandidate(parent.id);

    if (!result) {
      return null;
    }
    return permission.filter(result);
  }

  @graphql.ResolveField(() => Recruiter, { nullable: true })
  @nestAccessControl.UseRoles({
    resource: "User",
    action: "read",
    possession: "any",
  })
  async recruiter(
    @graphql.Parent() parent: User,
    @gqlUserRoles.UserRoles() userRoles: string[]
  ): Promise<Recruiter | null> {
    const permission = this.rolesBuilder.permission({
      role: userRoles,
      action: "read",
      possession: "any",
      resource: "Recruiter",
    });
    const result = await this.service.getRecruiter(parent.id);

    if (!result) {
      return null;
    }
    return permission.filter(result);
  }
}
